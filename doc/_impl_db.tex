\FloatBarrier
\section{Database}

Finally, it is important to note the last component of miq
that is the SQLite database that persists the information
about what packages are available in the store. This is done
because on each successive run of the program, it should be
able to tell which packages are already available on disk,
to avoid rebuilding them again. A naive solution is to just
read what paths are available in the store directory
|/miq/store|, but this may be error-prone, as the user may
insert or remove packages manually, or there could be
badly-built leftovers.

Similarly to
nix, miq connects to a SQLite database upon each build,
located in the path:

\begin{minted}{text}
/miq/db.sqlite
\end{minted}

This is implemented used the |diesel| Rust crate, which
provides an \acl{ORM} that wraps the SQL statements to query
and modify the database. The database schema is as simple as
possible, as only the packages paths are store in it. The
migration SQL statement is defined as the following snippet:

\begin{minted}{sql}
CREATE TABLE store (
    store_path VARCHAR NOT NULL PRIMARY KEY
)
\end{minted}

|diesel| is able to parse this SQL migration and generate
proper bindings to use in the Rust implementation. To do so,
it is used the type |diesel::SqliteConnection| is wrapped in
a |RefCell|. This is done to get around Rust's borrow rules,
that don't allow to have both mutable and immutable
references to the same object. The following snippet shows
how the wrapping type is defined, and the usage of the
\ac{ORM} with derive macros to easily query the database for
the existing Units:

\begin{minted}{rust}
#[derive(Debug, Queryable, Selectable)]
#[diesel(table_name = store)]
struct StorePath {
    store_path: String,
}

struct DbConnection {
    inner: RefCell<SqliteConnection>,
}

impl DbConnection {
    pub fn list(&self) -> Result<Vec<StorePath>> {
        let p: Vec<StorePath> = store.load::<StorePath>(
            self.inner.borrow_mut().deref_mut()
        )?;
        Ok(p)
    }

    // ...
}
\end{minted}

As discussed in section \ref{sec:concurrency}, the builder
subsystem spawns multiple threads concurrently to build all
the packages in parallel as soon as it is able to. On of
Rust's main features is that the type system and borrow
rules automatically prevent race conditions. The database's
methods that modify it, require that the database itself is
borrowed as mutable. For example in the type signature of
the insert statement (composed of some steps in between),
the database connection is borrowed as mutable in the last
step:

\begin{minted}{rust}
fn execute(query: Self, conn: &mut C) -> QueryResult<usize>;
\end{minted}

Rust's borrow rules don't allow to share a mutable reference
(to the database connection) across multiple threads, which
avoids race conditions of multiple threads trying to write
to the database in parallel. To avoid this, the database
connection can be wrapped in a |std::sync::Mutex|, this is a
mutual exclusion primitive that allows to lock the resource
when one thread is using it. The mutex has a method
|.lock()|, such that one is able to obtain a mutable
reference to the object in the mutex itself. While the mutex
is locked, no other thread is able to also |.lock()| it,
thus eliminating the possibility of a race condition. The
mutex lock is automatically released when it falls out of
scope.

Finally, as the type signature of the |.lock()| function is
the following:

\begin{minted}{rust}
pub fn lock(&self) -> LockResult<MutexGuard<'_, T>>;
\end{minted}

An immutable reference to the mutex is required in each thread
to be able to access it. The thread spawning mechanism in
Tokio (the async runtime) require that each thread is
generated by a function that owns the data that it uses. For
this reason, a shared reference |&'a| cannot be used, as it
doesn't own its data. The mutex then must be wrapped into a
pointer that can share the data among many threads, in
specific a |std::sync::Arc|, which stands for ``Atomically
Reference Counted'' pointer. This pointer is able to perform
atomic operation on the pointed data so that it is
thread-safe, such as reading its contents.

So in the end, the database connection is wrapped in the
following construct:

\begin{minted}{rust}
let db_conn = Arc::new(Mutex::new(crate::db::DbConnection::new()?));
\end{minted}

The build operations perform the following actions, which
can be done by multiple threads concurrently:

\begin{enumerate}
    \item Query the database for the Unit's store path.
    \item If the path is already available, skip the build
    and return OK.
    \item After the build is completed successfully, insert
    the path into the database.
\end{enumerate}

Every time miq is run, the store paths that have been built
are persisted into the database, such that the program is
able to know if the store path has already been built --
instead of relying on reading the existing folders in
|/miq/store| path.

The database can be manually queried to inspect if a package
is registered properly:

\begin{minted}{text}
$ sqlite3 /miq/db.sqlite

sqlite> .tables
__diesel_schema_migrations  store

sqlite> SELECT * FROM store;
/miq/store/unpack-bootstrap-tools.sh-6949dd1f64cfe7b6
/miq/store/busybox-33a90b67a497c4d6
/miq/store/musl-1.2.3.tar.gz-828bf8f78328fb26
/miq/store/toybox-x86_64-69a4327d80d88104
/miq/store/gmp-6.2.1.tar.bz2-a8db6558fa4fba6b
/miq/store/m4-1.4.19.tar.bz2-6732a25e4458acb
/miq/store/bootstrap-tools.tar.xz-9d678d0fc5041f17
\end{minted}

%
