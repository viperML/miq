
@inproceedings{gamblin_spack_2015,
	title = {The Spack package manager: Bringing order to {HPC} software chaos},
	volume = {15-20-November-2015},
	doi = {10.1145/2807591.2807623},
	abstract = {Large {HPC} centers spend considerable time supporting software for thousands of users, but the complexity of {HPC} software is quickly outpacing the capabilities of existing software management tools. Scientific applications require specific versions of compilers, {MPI}, and other dependency libraries, so using a single, standard software stack is infeasible. However, managing many configurations is difficult because the configuration space is combinatorial in size. We introduce Spack, a tool used at Lawrence Livermore National Laboratory to manage this complexity. Spack provides a novel, recursive specification syntax to invoke parametric builds of packages and dependencies. It allows any number of builds to coexist on the same system, and it ensures that installed packages can find their dependencies, regardless of the environment. We show through real-world use cases that Spack supports diverse and demanding applications, bringing order to {HPC} software chaos.},
	booktitle = {International Conference for High Performance Computing, Networking, Storage and Analysis, {SC}},
	author = {Gamblin, Todd and Legendre, Matthew and Collette, Michael R. and Lee, Gregory L. and Moody, Adam and Supinski, Bronis R. De and Futral, Scott},
	date = {2015},
	note = {{ISSN}: 21674337},
	file = {The Spack package manager\: Bringing order to HPC software chaos:C\:\\Users\\ayats\\Zotero\\storage\\DVPBYBM7\\gamblin2015.pdf.pdf:application/pdf},
}

@inproceedings{abate_dependency_2020,
	title = {Dependency Solving Is Still Hard, but We Are Getting Better at It},
	doi = {10.1109/SANER48275.2020.9054837},
	abstract = {Dependency solving is a hard ({NP}-complete) problem in all non-trivial component models due to either mutually incompatible versions of the same packages or explicitly declared package conflicts. As such, software upgrade planning needs to rely on highly specialized dependency solvers, lest falling into pitfalls such as incompleteness - a combination of package versions that satisfy dependency constraints does exist, but the package manager is unable to find it. In this paper we look back at proposals from dependency solving research dating back a few years. Specifically, we review the idea of treating dependency solving as a separate concern in package manager implementations, relying on generic dependency solvers based on tried and tested techniques such as {SAT} solving, {PBO}, {MILP}, etc. By conducting a census of dependency solving capabilities in state-of-the-art package managers we conclude that some proposals are starting to take off (e.g., {SAT}-based dependency solving) while - with few exceptions - others have not (e.g., outsourcing dependency solving to reusable components). We reflect on why that has been the case and look at novel challenges for dependency solving that have emerged since.},
	booktitle = {{SANER} 2020 - Proceedings of the 2020 {IEEE} 27th International Conference on Software Analysis, Evolution, and Reengineering},
	author = {Abate, Pietro and Cosmo, Roberto {DI} and Gousios, Georgios and Zacchiroli, Stefano},
	date = {2020},
	file = {Dependency Solving Is Still Hard, but We Are Getting Better at It:C\:\\Users\\ayats\\Zotero\\storage\\35C2RQVZ\\abate2020.pdf.pdf:application/pdf},
}

@article{courtes_functional_2013,
	title = {Functional Package Management with Guix},
	url = {http://arxiv.org/abs/1305.4584},
	abstract = {We describe the design and implementation of {GNU} Guix, a purely functional package manager designed to support a complete {GNU}/Linux distribution. Guix supports transactional upgrades and roll-backs, unprivileged package management, per-user profiles, and garbage collection. It builds upon the low-level build and deployment layer of the Nix package manager. Guix uses Scheme as its programming interface. In particular, we devise an embedded domain-specific language ({EDSL}) to describe and compose packages. We demonstrate how it allows us to benefit from the host general-purpose programming language while not compromising on expressiveness. Second, we show the use of Scheme to write build programs, leading to "two-tier" programming system.},
	author = {Courtès, Ludovic},
	date = {2013-05},
}

@inproceedings{kell_missing_2016,
	title = {The missing link: explaining {ELF} static linking, semantically},
	isbn = {978-1-4503-4444-9},
	url = {https://dl.acm.org/doi/10.1145/2983990.2983996},
	doi = {10.1145/2983990.2983996},
	pages = {607--623},
	booktitle = {Proceedings of the 2016 {ACM} {SIGPLAN} International Conference on Object-Oriented Programming, Systems, Languages, and Applications},
	publisher = {{ACM}},
	author = {Kell, Stephen and Mulligan, Dominic P. and Sewell, Peter},
	date = {2016-10},
}

@inproceedings{sun_security_2018,
	title = {Security Namespace: Making Linux Security Frameworks Available to Containers},
	doi = {10.5555/3277203.3277310},
	abstract = {Lightweight virtualization (i.e., containers) offers a virtual host environment for applications without the need for a separate kernel, enabling better resource utilization and improved efficiency. However, the shared kernel also prevents containers from taking advantage of security features that are available to traditional {VMs} and hosts. Containers cannot apply local policies to govern integrity measurement, code execution, mandatory access control, etc. to prevent application-specific security problems. Changes have been proposed to make kernel security mechanisms available to containers, but such changes are often adhoc and expose the challenges of trusting containers to make security decisions without compromising host system or other containers. In this paper, we propose security namespaces, a kernel abstraction that enables containers to have an autonomous control over their security. The security namespace relaxes the global and mandatory assumption of kernel security frameworks, thus enabling containers to independently define security policies and apply them to a limited scope of processes. To preserve security, we propose a routing mechanism that can dynamically dispatch an operation to a set of containers whose security might be affected by the operation, therefore ensuring the security decision made by one container cannot compromise the host or other containers. We demonstrate security namespace by developing namespaces for integrity measurement and mandatory access control in the Linux kernel for use by Docker containers. Results show that security namespaces can effectively mitigate security problems within containers (e.g., malicious code execution) with less than 0.7\% additional latency to system call and almost identical application throughput. As a result, security namespaces enable containers to obtain autonomous control over their security without compromising the security of other containers or the host system.},
	pages = {1423--1439},
	booktitle = {Proceedings of the 27th {USENIX} Conference on Security Symposium},
	publisher = {{USENIX} Association},
	author = {Sun, Yuqiong and Safford, David and Zohar, Mimi and Pendarakis, Dimitrios and Gu, Zhongshu and Jaeger, Trent},
	date = {2018},
}

@article{raknes_nsroot_2016,
	title = {nsroot: Minimalist Process Isolation Tool Implemented With Linux Namespaces},
	abstract = {Data analyses in the life sciences are moving from tools run on a personal computer to services run on large computing platforms. This creates a need to package tools and dependencies for easy installation, configuration and deployment on distributed platforms. In addition, for secure execution there is a need for process isolation on a shared platform. Existing virtual machine and container technologies are often more complex than traditional Unix utilities, like chroot, and often require root privileges in order to set up or use. This is especially challenging on {HPC} systems where users typically do not have root access. We therefore present nsroot, a lightweight Linux namespaces based process isolation tool. It allows restricting the runtime environment of data analysis tools that may not have been designed with security as a top priority, in order to reduce the risk and consequences of security breaches, without requiring any special privileges. The codebase of nsroot is small, and it provides a command line interface similar to chroot. It can be used on all Linux kernels that implement user namespaces. In addition, we propose combining nsroot with the {AppImage} format for secure execution of packaged applications. nsroot is open sourced and available at: https://github.com/uit-no/nsroot},
	author = {Raknes, Inge Alexander and Fjukstad, Bjørn and Bongo, Lars Ailo},
	date = {2016-09},
}

@inproceedings{dolstra_nixos_2008,
	title = {{NixOS}},
	isbn = {978-1-59593-919-7},
	doi = {10.1145/1411204.1411255},
	pages = {367--378},
	booktitle = {Proceedings of the 13th {ACM} {SIGPLAN} international conference on Functional programming},
	publisher = {{ACM}},
	author = {Dolstra, Eelco and Löh, Andres},
	date = {2008-09},
}

@book{dolstra_purely_2006,
	title = {The purely functional software deployment model},
	isbn = {90-393-4130-3},
	publisher = {Utrecht University},
	author = {Dolstra, Eelco},
	date = {2006},
}

@article{ritchie_unix_1984,
	title = {The {UNIX} System: The Evolution of the {UNIX} Time‐sharing System},
	volume = {63},
	issn = {15387305},
	doi = {10.1002/j.1538-7305.1984.tb00054.x},
	abstract = {This paper presents a brief history of the early development of the {UNIX}™ operating system. It concentrates on the evolution of the file system, the process‐control mechanism, and the idea of pipelined commands. Some attention is paid to social conditions during the development of the system. This paper is reprinted from Lecture Notes on Computer Science, No. 79, Language Design and Programming Methodology, Springer‐Verlag, 1980. © 1984 {AT}\&T Bell Laboratories Technical Journal},
	number = {8},
	journaltitle = {{AT}\&T Bell Laboratories Technical Journal},
	author = {Ritchie, D. M.},
	date = {1984},
	file = {The UNIX System\: The Evolution of the UNIX Time‐sharing System:C\:\\Users\\ayats\\Zotero\\storage\\5A8LM6Z6\\ritchie1984.pdf.pdf:application/pdf},
}

@online{noauthor_fhs_nodate,
	title = {{FHS}, Linux Foundation Wiki},
	url = {https://wiki.linuxfoundation.org/lsb/fhs},
	urldate = {2023-05-29},
	file = {lsb\:fhs [Wiki]:C\:\\Users\\ayats\\Zotero\\storage\\833M3UX3\\fhs.html:text/html},
}

@article{merkel_docker_2014,
	title = {Docker: lightweight Linux containers for consistent development and deployment},
	url = {https://www.semanticscholar.org/paper/Docker%3A-lightweight-Linux-containers-for-consistent-Merkel/875d90d4f66b07f90687b27ab304e04a3f666fc2},
	shorttitle = {Docker},
	abstract = {Docker promises the ability to package applications and their dependencies into lightweight containers that move easily between different distros, start up quickly and are isolated from each other.},
	journaltitle = {Linux Journal},
	author = {Merkel, Dirk},
	urldate = {2023-05-29},
	date = {2014-03-01},
	file = {Full Text PDF:C\:\\Users\\ayats\\Zotero\\storage\\BMA7GVST\\Merkel - 2014 - Docker lightweight Linux containers for consisten.pdf:application/pdf},
}

@online{noauthor_everything_nodate,
	title = {Everything You Need to Know about Linux Containers},
	url = {https://www.linuxjournal.com/content/everything-you-need-know-about-linux-containers-part-ii-working-linux-containers-lxc},
	urldate = {2023-05-29},
	file = {Everything You Need to Know about Linux Containers, Part II\: Working with Linux Containers (LXC) | Linux Journal:C\:\\Users\\ayats\\Zotero\\storage\\MPSJU67K\\everything-you-need-know-about-linux-containers-part-ii-working-linux-containers-lxc.html:text/html},
}

@article{al-mutawa_shape_2014,
	title = {On the Shape of Circular Dependencies in Java Programs},
	url = {http://ieeexplore.ieee.org/document/6824106/},
	doi = {10.1109/ASWEC.2014.15},
	abstract = {Circular dependencies between software artefacts are widely considered as problematic. However, empirical studies of Java programs have shown that most programs are riddled with circular dependencies. This seems to imply that not all circular dependencies are as detrimental to software quality as previously thought. Clearly, a better understanding of the types of circular dependency and their effect on software quality is required. In this paper, we provide precise definitions for different types of circular dependencies, analyse their topology and investigate the relationship between circular dependencies and the package containment tree. Our analysis is based on the popular Qualities Corpus data set. We find that in package dependency graphs, most circular dependencies are "package local": they are confined to branches of the package containment tree where they form around parent packages. Existing research indicates that these dependencies may not be critical. This may explain why circular dependencies are so common in widely-used real-world programs.},
	pages = {48--57},
	journaltitle = {2014 23rd Australian Software Engineering Conference},
	author = {Al-Mutawa, Hussain A. and Dietrich, Jens and Marsland, Stephen and {McCartin}, Catherine},
	urldate = {2023-05-29},
	date = {2014-04},
	note = {Conference Name: 2014 23rd Australian Software Engineering Conference ({ASWEC})
{ISBN}: 9781479931491
Place: Milsons Point, {NSW}, Australia
Publisher: {IEEE}},
	file = {On the Shape of Circular Dependencies in Java Programs:C\:\\Users\\ayats\\Zotero\\storage\\N3MGJ3GZ\\al-mutawa2014.pdf.pdf:application/pdf},
}

@online{noauthor_docker_2022,
	title = {Docker: Accelerated, Containerized Application Development},
	url = {https://www.docker.com/},
	shorttitle = {Docker},
	abstract = {Docker is a platform designed to help developers build, share, and run modern applications. We handle the tedious setup, so you can focus on the code.},
	urldate = {2023-05-29},
	date = {2022-05-10},
	langid = {american},
}

@article{elizalde_zapata_towards_2018,
	title = {Towards Smoother Library Migrations: A Look at Vulnerable Dependency Migrations at Function Level for npm {JavaScript} Packages},
	url = {https://ieeexplore.ieee.org/document/8530065/},
	doi = {10.1109/ICSME.2018.00067},
	shorttitle = {Towards Smoother Library Migrations},
	abstract = {It has become common practice for software projects to adopt third-party libraries, allowing developers full access to functions that otherwise will take time and effort to create them-selves. Regardless of migration effort involved, developers are encouraged to maintain their library dependencies by updating any outdated dependency, so as to remain safe from potential threats such as vulnerabilities. Through a manual inspection of a total of 60 client projects from three cases of high severity vulnerabilities, we investigate whether or not clients are really safe from these threats. Surprisingly, our early results show evidence that up to 73.3\% of outdated clients were actually safe from the threat. This is the first work to confirm that analysis at the library level is indeed an overestimation. This result to pave the path for future studies to empirically investigate and validate this phenomena, and is towards aiding a smoother library migration for client developers.},
	pages = {559--563},
	journaltitle = {2018 {IEEE} International Conference on Software Maintenance and Evolution ({ICSME})},
	author = {Elizalde Zapata, Rodrigo and Kula, Raula Gaikovina and Chinthanet, Bodin and Ishio, Takashi and Matsumoto, Kenichi and Ihara, Akinori},
	urldate = {2023-05-29},
	date = {2018-09},
	note = {Conference Name: 2018 {IEEE} International Conference on Software Maintenance and Evolution ({ICSME})
{ISBN}: 9781538678701
Place: Madrid
Publisher: {IEEE}},
	file = {Towards Smoother Library Migrations\: A Look at Vulnerable Dependency Migrations at Function Level for npm JavaScript Packages:C\:\\Users\\ayats\\Zotero\\storage\\JPJI8BHQ\\71973028064296a95e0cb96726c268a1.pdf.pdf:application/pdf},
}

@article{mukherjee_fixing_2021,
	title = {Fixing dependency errors for Python build reproducibility},
	url = {https://dl.acm.org/doi/10.1145/3460319.3464797},
	doi = {10.1145/3460319.3464797},
	abstract = {Software reproducibility is important for re-usability and the cumulative progress of research. An important manifestation of unreproducible software is the changed outcome of software builds over time. While enhancing code reuse, the use of open-source dependency packages hosted on centralized repositories such as {PyPI} can have adverse effects on build reproducibility. Frequent updates to these packages often cause their latest versions to have breaking changes for applications using them. Large Python applications risk their historical builds becoming unreproducible due to the widespread usage of Python dependencies, and the lack of uniform practices for dependency version specification. Manually fixing dependency errors requires expensive developer time and effort, while automated approaches face challenges of parsing unstructured build logs, finding transitive dependencies, and exploring an exponential search space of dependency versions. In this paper, we investigate how open-source Python projects specify dependency versions, and how their reproducibility is impacted by dependency packages. We propose a tool {PyDFix} to detect and fix unreproducibility in Python builds caused by dependency errors. {PyDFix} is evaluated on two bug datasets {BugSwarm} and {BugsInPy}, both of which are built from real-world open-source projects. {PyDFix} analyzes a total of 2,702 builds, identifying 1,921 (71.1\%) of them to be unreproducible due to dependency errors. From these, {PyDFix} provides a complete fix for 859 (44.7\%) builds, and partial fixes for an additional 632 (32.9\%) builds.},
	pages = {439--451},
	journaltitle = {Proceedings of the 30th {ACM} {SIGSOFT} International Symposium on Software Testing and Analysis},
	author = {Mukherjee, Suchita and Almanza, Abigail and Rubio-González, Cindy},
	urldate = {2023-05-29},
	date = {2021-07-11},
	langid = {english},
	note = {Conference Name: {ISSTA} '21: 30th {ACM} {SIGSOFT} International Symposium on Software Testing and Analysis
{ISBN}: 9781450384599
Place: Virtual Denmark
Publisher: {ACM}},
	file = {Fixing dependency errors for Python build reproducibility:C\:\\Users\\ayats\\Zotero\\storage\\8KBQ4H39\\mukherjee2021.pdf.pdf:application/pdf;Full Text:C\:\\Users\\ayats\\Zotero\\storage\\C85MNZ47\\Mukherjee et al. - 2021 - Fixing dependency errors for Python build reproduc.pdf:application/pdf},
}
